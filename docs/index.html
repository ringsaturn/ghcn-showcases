<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Protomaps with Leaflet</title>

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""
    />

    <!-- Leaflet JavaScript -->
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      crossorigin=""
    ></script>
    <script src="https://unpkg.com/protomaps-leaflet@5.0.1/dist/protomaps-leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        width: 100%;
        height: 100vh;
      }

      .lang-switch {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background: white;
        padding: 5px 10px;
        border-radius: 4px;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="lang-switch" onclick="toggleLanguage()">
      <span id="langText">EN</span>
    </div>


    <script>
      // Language configuration
      const translations = {
        zh: {
          stationInfo: '气象站点信息',
          stationId: '站点编号',
          name: '站点名称',
          longitude: '经度',
          latitude: '纬度',
          elevation: '海拔高度',
          dailyChart: '日温度变化',
          monthlyChart: '月温度变化',
          meters: '米',
          month: '月',
          day: '日',
          monthAxis: '月份',
          tempAxis: '温度 (°C)',
          maxTemp: '90分位最高温度',
          minTemp: '10分位最低温度',
          precipAxis: '降水量 (mm)',
          precip: '降水量'
        },
        en: {
          stationInfo: 'Weather Station Information',
          stationId: 'Station ID',
          name: 'Station Name',
          longitude: 'Longitude',
          latitude: 'Latitude',
          elevation: 'Elevation',
          dailyChart: 'Daily Temperature Variation',
          monthlyChart: 'Monthly Temperature Variation',
          meters: 'm',
          month: '',
          day: '',
          monthAxis: 'Month',
          tempAxis: 'Temperature (°C)',
          maxTemp: '90th Percentile Max Temperature',
          minTemp: '10th Percentile Min Temperature',
          precipAxis: 'Precipitation (mm)',
          precip: 'Precipitation'
        }
      };

      // Get browser language setting and set initial language
      function getInitialLanguage() {
        const browserLang = navigator.language.toLowerCase();
        // If browser language starts with zh (like zh-CN, zh-TW, etc.), use Chinese, otherwise English
        return browserLang.startsWith('zh') ? 'zh' : 'en';
      }

      let currentLang = getInitialLanguage();

      // Set initial language display
      document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('langText').textContent = currentLang === 'zh' ? 'EN' : '中';
      });

      function toggleLanguage() {
        currentLang = currentLang === 'zh' ? 'en' : 'zh';
        document.getElementById('langText').textContent = currentLang === 'zh' ? 'EN' : '中';
        // Update map language
        updateMapLanguage();
        // Update popup content for all markers
        stationsLayer.eachLayer(function(layer) {
          // Update popup content
          layer.bindPopup(generatePopupContent(layer.feature));
          // If popup is currently open, refresh display and reload chart
          if (layer.getPopup() && layer.getPopup().isOpen()) {
            layer.getPopup().update();
            loadChartData(layer.feature.properties.ID);
          }
        });
      }

      async function loadChartData(stationId) {
        // Define chartDefaults inside the function so it can access currentLang
        const chartDefaults = {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'nearest',
            axis: 'x'
          },
          plugins: {
            legend: {
              position: "top",
              labels: {
                padding: 15,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              enabled: true,
              backgroundColor: 'rgba(255, 255, 255, 0.9)',
              titleColor: '#000',
              bodyColor: '#000',
              borderColor: '#ddd',
              borderWidth: 1,
              padding: 10,
              displayColors: true,
              titleAlign: 'center',
              callbacks: {
                title: function(tooltipItems) {
                  const item = tooltipItems[0];
                  if (!item || !item.raw) return '';
                  return item.raw.dateStr;
                },
                label: function(item) {
                  if (item.dataset.label === translations[currentLang].precip) {
                    return `${item.dataset.label}: ${item.parsed.y.toFixed(1)}mm`;
                  }
                  return `${item.dataset.label}: ${item.parsed.y.toFixed(1)}°C`;
                }
              }
            }
          },
          scales: {
            x: {
              type: "time",
              time: {
                unit: "month",
                displayFormats: {
                  month: `M${translations[currentLang].month}`,
                  day: `M${translations[currentLang].month}d${translations[currentLang].day}`
                },
                tooltipFormat: `M${translations[currentLang].month}d${translations[currentLang].day}`
              },
              grid: {
                color: '#eee'
              },
              title: {
                display: true,
                text: translations[currentLang].monthAxis,
                padding: {top: 10, bottom: 10},
                font: {
                  size: 14
                }
              },
              ticks: {
                maxRotation: 0,
                font: {
                  size: 12
                }
              }
            },
            y: {
              position: 'left',
              grid: {
                color: '#eee'
              },
              title: {
                display: true,
                text: translations[currentLang].tempAxis,
                padding: {top: 10, bottom: 10},
                font: {
                  size: 14
                }
              },
              ticks: {
                font: {
                  size: 12
                }
              }
            },
            y1: {
              position: 'right',
              grid: {
                drawOnChartArea: false
              },
              title: {
                display: true,
                text: translations[currentLang].precipAxis,
                padding: {top: 10, bottom: 10},
                font: {
                  size: 14
                }
              },
              ticks: {
                font: {
                  size: 12
                }
              }
            }
          }
        };

        // Load and draw charts
        await Promise.all([
          fetch("plots/" + stationId + "-daily.csv")
            .then(response => response.text())
            .then(csvData => {
              const results = Papa.parse(csvData, { header: true });
              const data = results.data;
              
              // Construct date data
              // Set fixed year and ignore display
              const baseDate = new Date(2020, 0, 1);
              const chartData = data.map(row => {
                const month = parseInt(row.MONTH);
                const day = parseInt(row.DAY_OF_MONTH);
                return {
                  x: new Date(baseDate.getFullYear(), month - 1, day),
                  y_max: parseFloat(row.TMAX_P90),
                  y_min: parseFloat(row.TMIN_P10),
                  y_prcp: parseFloat(row.PRCP_SUM) || 0,
                  month: month,
                  day: day,
                  dateStr: month + translations[currentLang].month + day + translations[currentLang].day
                };
              }).filter(point => !isNaN(point.y_max) && !isNaN(point.y_min));

              // Calculate temperature range
              const temperatures = chartData.flatMap(point => [point.y_max, point.y_min]);
              const minTemp = Math.floor(Math.min(...temperatures));
              const maxTemp = Math.ceil(Math.max(...temperatures));
              
              new Chart(document.getElementById("dailyChart-" + stationId), {
                type: "line",
                data: {
                  datasets: [
                    {
                      label: translations[currentLang].maxTemp,
                      data: chartData.map(point => ({x: point.x, y: point.y_max})),
                      borderColor: "rgba(255, 99, 132, 0.8)",
                      backgroundColor: "rgba(255, 99, 132, 0.1)",
                      borderWidth: 1.5,
                      pointRadius: 0,
                      fill: false,
                      tension: 0.2,
                      yAxisID: 'y'
                    },
                    {
                      label: translations[currentLang].minTemp,
                      data: chartData.map(point => ({x: point.x, y: point.y_min})),
                      borderColor: "rgba(54, 162, 235, 0.8)",
                      backgroundColor: "rgba(54, 162, 235, 0.1)",
                      borderWidth: 1.5,
                      pointRadius: 0,
                      fill: false,
                      tension: 0.2,
                      yAxisID: 'y'
                    },
                    {
                      label: translations[currentLang].precip,
                      data: chartData.map(point => ({x: point.x, y: point.y_prcp})),
                      borderColor: "rgba(75, 192, 192, 0.8)",
                      backgroundColor: "rgba(75, 192, 192, 0.2)",
                      borderWidth: 1.5,
                      pointRadius: 0,
                      fill: true,
                      tension: 0.2,
                      yAxisID: 'y1'
                    }
                  ]
                },
                options: {
                  ...chartDefaults,
                  scales: {
                    ...chartDefaults.scales,
                    y: {
                      ...chartDefaults.scales.y,
                      min: minTemp - 2,
                      max: maxTemp + 2,
                      ticks: {
                        stepSize: 5
                      }
                    }
                  }
                }
              });
            }),
          
          fetch("plots/" + stationId + "-monthly.csv")
            .then(response => response.text())
            .then(csvData => {
              const results = Papa.parse(csvData, { header: true });
              const data = results.data;
              
              // Construct monthly data
              // Set fixed year and ignore display
              const baseDate = new Date(2020, 0, 1);
              const chartData = data.map(row => {
                const month = parseInt(row.MONTH);
                return {
                  x: new Date(baseDate.getFullYear(), month - 1, 1),
                  y_max: parseFloat(row.TMAX_P90),
                  y_min: parseFloat(row.TMIN_P10),
                  y_prcp: parseFloat(row.PRCP_SUM) || 0,
                  month: month,
                  dateStr: month + translations[currentLang].month
                };
              }).filter(point => !isNaN(point.y_max) && !isNaN(point.y_min));

              // Calculate temperature range
              const temperatures = chartData.flatMap(point => [point.y_max, point.y_min]);
              const minTemp = Math.floor(Math.min(...temperatures));
              const maxTemp = Math.ceil(Math.max(...temperatures));
              
              new Chart(document.getElementById("monthlyChart-" + stationId), {
                type: "line",
                data: {
                  datasets: [
                    {
                      label: translations[currentLang].maxTemp,
                      data: chartData.map(point => ({x: point.x, y: point.y_max})),
                      borderColor: "rgba(255, 99, 132, 0.8)",
                      backgroundColor: "rgba(255, 99, 132, 0.1)",
                      borderWidth: 2,
                      pointRadius: 4,
                      pointBackgroundColor: "rgba(255, 99, 132, 1)",
                      fill: false,
                      tension: 0.3,
                      yAxisID: 'y'
                    },
                    {
                      label: translations[currentLang].minTemp,
                      data: chartData.map(point => ({x: point.x, y: point.y_min})),
                      borderColor: "rgba(54, 162, 235, 0.8)",
                      backgroundColor: "rgba(54, 162, 235, 0.1)",
                      borderWidth: 2,
                      pointRadius: 4,
                      pointBackgroundColor: "rgba(54, 162, 235, 1)",
                      fill: false,
                      tension: 0.3,
                      yAxisID: 'y'
                    },
                    {
                      label: translations[currentLang].precip,
                      data: chartData.map(point => ({x: point.x, y: point.y_prcp})),
                      borderColor: "rgba(75, 192, 192, 0.8)",
                      backgroundColor: "rgba(75, 192, 192, 0.2)",
                      borderWidth: 2,
                      pointRadius: 4,
                      pointBackgroundColor: "rgba(75, 192, 192, 1)",
                      fill: true,
                      tension: 0.3,
                      yAxisID: 'y1'
                    }
                  ]
                },
                options: {
                  ...chartDefaults,
                  scales: {
                    ...chartDefaults.scales,
                    y: {
                      ...chartDefaults.scales.y,
                      position: 'left',
                      min: minTemp - 2,
                      max: maxTemp + 2,
                      ticks: {
                        stepSize: 5
                      }
                    },
                    y1: {
                      position: 'right',
                      grid: {
                        drawOnChartArea: false
                      },
                      title: {
                        display: true,
                        text: translations[currentLang].precipAxis,
                        padding: {top: 10, bottom: 10},
                        font: {
                          size: 14
                        }
                      },
                      ticks: {
                        font: {
                          size: 12
                        }
                      }
                    }
                  }
                }
              });
            })
        ]);
      }

      function generatePopupContent(feature) {
        const t = translations[currentLang];
        const properties = feature.properties;
        const coordinates = feature.geometry.coordinates;
        const stationId = properties.ID;
        
        return `
          <div style="width: 80vw; max-width: 800px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); box-sizing: border-box;">
            <h3 style="margin-top: 0; margin-bottom: 10px;">${t.stationInfo}</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 20px">
              <p style="margin: 5px 0"><strong>${t.stationId}:</strong> ${properties.ID}</p>
              <p style="margin: 5px 0"><strong>${t.name}:</strong> ${properties.NAME}</p>
              <p style="margin: 5px 0"><strong>${t.longitude}:</strong> ${coordinates[0].toFixed(2)}°</p>
              <p style="margin: 5px 0"><strong>${t.latitude}:</strong> ${coordinates[1].toFixed(2)}°</p>
              <p style="margin: 5px 0"><strong>${t.elevation}:</strong> ${properties.ELEVATION}${t.meters}</p>
            </div>
            <div style="margin-top: 20px; display: flex; flex-direction: column; gap: 20px;">
              <div>
                <h4 style="margin: 0 0 10px;">${t.dailyChart}</h4>
                <div style="width: 100%; margin-bottom: 0; background: #f8f9fa; padding: 10px; border-radius: 4px; box-sizing: border-box;">
                  <canvas id="dailyChart-${stationId}" style="width: 100%; height: 250px;"></canvas>
                </div>
              </div>
              <div>
                <h4 style="margin: 0 0 10px;">${t.monthlyChart}</h4>
                <div style="width: 100%; background: #f8f9fa; padding: 10px; border-radius: 4px; box-sizing: border-box;">
                  <canvas id="monthlyChart-${stationId}" style="width: 100%; height: 250px;"></canvas>
                </div>
              </div>
            </div>
          </div>
        `;
      }

      // Initialize map, set center and zoom level
      const map = L.map("map").setView([35, 130], 5); // Set view center in East China Sea area to see both China and Japan

      function updateMapLanguage() {
        // If map layer already exists, remove it
        if (window.baseLayer) {
          map.removeLayer(window.baseLayer);
        }
        
        // Create new map layer
        window.baseLayer = protomapsL.leafletLayer({
          url: "https://api.protomaps.com/tiles/v4/{z}/{x}/{y}.mvt?key=019532177fa38e19",
          flavor: "white",
          attribution:
            '© <a href="https://protomaps.com">Protomaps</a> © <a href="https://openstreetmap.org">OpenStreetMap</a>',
          lang: currentLang === 'zh' ? 'zh' : 'en'
        });
        window.baseLayer.addTo(map);
      }

      // Initialize map layer
      updateMapLanguage();

      // Load station data
      fetch('./matched_stations.geojson')
        .then(response => response.json())
        .then(data => {
          // Create station layer
          window.stationsLayer = L.geoJSON(data, {
            pointToLayer: function(feature, latlng) {
              return L.marker(latlng);
            },
            onEachFeature: function(feature, layer) {
              const popup = L.popup().setContent(generatePopupContent(feature));
              layer.bindPopup(popup);
              
              // Load data only when popup opens
              layer.on('popupopen', function() {
                loadChartData(feature.properties.ID);
              });
            }
          }).addTo(map);
        });
    </script>
  </body>
</html>